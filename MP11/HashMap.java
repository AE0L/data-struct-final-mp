
/**
 * @author ASILO, Marvaux
 * @author CHUA, Orjan
 * @author GARCIA, Raphael Taylor
 * @author JIMENEZ, Carl Justin
 * @section BSCS 2-2
 *
 * @param <K> - the data type of the keys.
 * @param <V> - the data type of the nodes.
 */
public class HashMap<K, V> {

  private final int DEFAULT_BUCKETSIZE = 17;
  private List<Node<K, V>> bucket;
  private int bucketSize;
  private int size;

  public HashMap() {
    bucket = new List<>();
    bucketSize = DEFAULT_BUCKETSIZE;
    size = 0;

    for (int i = 0; i < bucketSize; i++)
      bucket.add(null);
  }

  public int size() {
    return this.size;
  }

  public boolean isEmpty() {
    return size() == 0;
  }

  /**
   * Generate the index of the node added in the hash map.
   * 
   * @param key - the key of the new node.
   * @return return the index to be used by the new node.
   */
  public int index(K key) {
    return Math.abs(key.hashCode()) % bucketSize;
  }

  /**
   * Add a new node with the given key and value. The index to be used is generated by the index
   * method. If the load factor is greater than 7 double the bucket size of the hash table.
   * 
   * @param key - the key of the node.
   * @param value - the value of the node.
   */
  public void add(K key, V value) {
    int index = index(key);
    Node<K, V> head = bucket.get(index);

    while (head != null) {
      if (head.value().equals(value)) {
        return;
      }

      head = head.next();
    }

    this.size++;
    head = bucket.get(index);
    Node<K, V> newNode = new Node<>(key, value);
    newNode.next(head);
    bucket.set(index, newNode);

    if ((1.0 * size) / bucketSize >= 7.0) {
      List<Node<K, V>> temp = bucket;
      bucket = new List<>();
      bucketSize = this.bucketSize * 2;
      size = 0;

      for (int i = 0; i < bucketSize; i++) {
        bucket.add(null);
      }

      for (Node<K, V> node : temp) {
        while (node != null) {
          add(node.key(), node.value());
          node = node.next();
        }
      }
    }
  }

  /**
   * Get the node/s with the matching key.
   * 
   * @param key - the key of the node to be search.
   * @return the node with the matching key and its connected nodes if there is any.
   */
  public Node<K, V> get(K key) {
    int index = index(key);
    Node<K, V> head = bucket.get(index);

    while (head != null) {
      if (head.key().equals(key)) {
        return head;
      }

      head = head.next();
    }

    return null;
  }


}
